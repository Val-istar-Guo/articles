# 为脏数据消毒

###### 不应该在组件渲染代码中为数据的正确性进行复杂判断，既：注入组件的数据必须为正确的。


对于稍大一些的项目，往往是多人合作开发。在前端和后端交互过程中，数据是否与预期相同是极为重要的。因为前端需要将数据展示到界面上供用户观看，例如我们获取了一个商品列表，我们会循环将列表的内容渲染为界面元素，但是如果商品列表为空时，接口返回的是null而不是空列表，我们的渲染代码就会直接挂掉。这时候前端就不得不多一个判断。但是当数据嵌套多层，有许多数据都需要判断的时候，前端就成了一坨shit。

那我们有必要要求服务提供者保证数据结构的正确性么？答案肯定是否定的。因为服务的提供者提供的某个数据字段只是依赖其他服务提供者，填充大量的默认字段对他们来说看上去像是一坨shit。更重要的是，服务的提供者代码也可能有bug导致字段数据出错。前端不能因为后端bug导致自身服务崩溃。

因此，在获得接口数据后，**对数据进行消毒后使用能够很好提高服务稳定性**，同时我们可以**提高组件渲染代码的可维护性**

简单的来说，我们可以在获取数据后对数据字段进行判断并附上默认值，然后再交给渲染逻辑部分进行渲染。但是如果我们数据中存在多层数据，那么我们用来消毒的代码可能写成多重循环，这让代码变得不容易维护。有时候，可能我们的接口为了未来的扩展性而保留一些多余的设计，例如多余的字段。有时候我们又要求数组至少有一个展示给用户的有意义的值，对于没有意义的数据我们要抛弃掉，避免渲染造成用户误操作。如果你真的通过循环判断的方法来写，这部分代码的维护将是及其痛苦的。这也是我开发 Sanitization 的缘由。


## 什么样的数据是合理的


### 完整的数据结构

数据结构的完整性是指，当我们获得的是一个空数组的数据时，这个数据应当是`[]`而不应该是`null`或`undefined`。因为如果为`null`，那么我们渲染代码中`arr.map`这类的循环代码可能报错，导致界面渲染失败。又比如获得的空对象是`null`，`obj.prop`代码也会报错。

**我们不应该在组件的渲染逻辑中判断判断数据是否为空进行不同的渲染**，我们应该将数据中的对象赋予完整的属性默认值和数组至少为空数组以保证渲染逻辑中的取值和循环操作可以正常运行。也保证渲染逻辑部分的代码是干净整洁、易于维护的。

### 有意义的数据

对于一条数据，其数据结构的完整并不代表可以将其渲染出来。**如果数据的关键信息异常，我们必须避免将其渲染到界面**，这些异常数据可能导致用户误操作。

例如，如果我们有一个用户购买商品的商品列表，我们获取了一个商品列表的数组，每一项都包含一条商品信息，如下：

```javascript
const goods = [
	{
		id: 1,
		name: '洗洁精',
		price: 10,
	},
	{
		id: 2,
		name: '晾衣架',
		price: null,
	},
]
```

可能由于后端服务出现异常，晾衣架的`price`数据并没有返回。我们并不应该将这个数据渲染到界面，避免用户选择购买该商品，最终导致前端计算价格和最终结算展示的价格不一致导致客户投诉。（同时我们或许应该上报这个数据异常）。因此，客户最终看到的可以操作的有效商品只有洗洁精。

### 不同的场景，不同的脏数据

**同样的一个接口获取的相同的数据信息，面对不同的操作者在不同的业务场景下，我们的处理方式往往是不同的。**为了说明这个问题，我依旧使用上面的例子提到的错误数据。

首先，我们分析一下`price`字段为空可能的两个原因：

1. 接口代码bug导致price字段为空
2. 数据库被存入了脏数据，接口将脏数据返回给了我们

在上个例子中，我们目的是展示给消费者进行操作。让我们换一个身份，我们现在是这个超市的管理员，我们需要编辑我的商品列表。

同样是上面的列表，这次渲染编辑页面的时候，不应该将`price`字段为null的数据过滤掉，而是将这个数据默认设置为一个空字符串。这样做的原因是，当管理员发现数据为空并重新填写保存后，如果是由于数据库被存入脏数据导致的数据为null的情况，数据会被修正并保存到数据库中。这样管理员可以最快速的解决问题，并让消费者看到商品。至于接口提供者，则可以根据日志去寻找脏数据产生原因并解决他们的问题了。


## 梦寐以求的工具应该具备什么

1. 可配置
2. 配置格式和数据格式高度一致
3. 支持过滤非法数据
4. 填充默认值，自动进行类型转换

## Sanitization

用一个复杂的例子来说明再好不过了。我们平常去超市，经常遇到换购活动，即：当你购买了100块钱的东西时，可以以优惠的价格10块钱多购买一个卫生纸加一个晾衣架，原价共计20元；或者以20元的价格多购买一个原价50元的拖把。

作为超市的管理者，你希望卫生纸和晾衣架是打包换购的，不单独换购。你还希望你的操作屏幕上能够让用户看到每个换购商品的图文信息，吸引消费者换购。

同时，你也是一位大隐于市的牛X前端，你和你的后端同学定了一个还算合理的数据结构：


```javascript
const idealData = {
	// 至少价格要达到100才能参与换购
	minPrice: 100,
	// 活动类型，假设2代表换购
	type: 2,

	// 可以换购的物品
	products: [{
		// 物品不能为空，否则消费者看到的可能就是花钱买空气了。
		items: [{
			name: '卫生纸',
			// 卫生纸原价
			price: 5,
			number: 1,
		}, {
			name: '晾衣架',
			price: 15,
			number: 1,
		}],
		// 换购价格
		price: 10,
	}, {
		items: [{
			name: '拖把',
			price: 50,
			number: 1,
		}],
		price: 20,
	}],
}
```

没有bug的代码就是什么都不写，后端服务数据如果出现异常，返回如下的信息。


```javascript
const data = {
	minPrice: 100,
	// type 我们获取的就是这个换购活动，因此不需要这个字段

	products: [{
		// 没有物品的换购谁花钱啊，这种数据应该过滤掉
		items: null,
		price: 10,
	}，{
		items: [{
			id: 1,
			name: '卫生纸',
			/**
			 * 卫生纸原价，原价即使不存在也不影响用户实际的消费
			 * 意不意外，惊不惊喜，由于后端bug导致数据输出了个空对象
			 */
			price: {},
			number: 1,
		}, {
			// id是商品的其他接口操作的标符，必须存在
			id: 2,
			name: '晾衣架',
			price: 5,
			/**
			 * 没有指明数量会导致消费者误操作
			 * 只展示卫生纸也不合理
			 * 因此整个换购项目都需要过滤掉
			 */
			number: null,
		}],

		// 这个价格也对消费者来说已非常重要
		price: 10,
	}, {
		items: [{
			name: '拖把',
			price: 50,
		}],
		price: 20,
	}]
}
```

### 展示给用户

分析一下我们的数据可以看出来，消费之能够安全操作的换购项目只有拖把那一项。
其他项目都会引起消费者误解，导致误操作，引起客户投诉，影响名声。

因此，为了安全起见，我们需要过滤掉这些内容，先看看如果我们使用传统的方式应该如何编码。


```javascript
const safeData = {
	...data,

	products: !data.products ? [] : data.products
		.map(product => {
			// 没有商品或者原价的是非法数据
			if (!product.items || typeof product.price !== 'number') return null;

			const someItemIllegal = product.items.some(item =>
				!item.id ||
				typeof item.price !== 'number');

			if (someItemIllegal) return null;


			const safeItems = items.map(item => ({
				...item,
				/**
				 * 如果价格原价信息不存在
				 * 在渲染NaN时提示用户原价数据异常
				 * 由于原价仅仅用于展示，对交易无影响
				 * 因此不需要移除项目，
				 * 同时NaN会造成项目总原价计算为NaN
				 * 总原价同时也可以提醒用户数据异常
				 * 总价格也仅仅是展示，对交易无影响
				 */
				price: item.price || NaN,
			}))

			return {
				...product,
				items: safeItems,
			};
		})
		// 过滤非法数据
		.filter(product => product)
}
```

这是多么大的一坨shit！这种代码维护起来简直让人痛苦。来瞧瞧我们如何同[sanitization](https://github.com/Val-istar-Guo/sanitization)改写：

```javascript
const sanizate = sa.keys({
	minPrice: sa.number.required(),
	products: sa.filter({
		items: sa.len(1).each({
			id: sa.number.required(),
			name: sa.string,
			price: sa.number,
			number: sa.number.required(),
		},
		price: sa.number.required(),
	}),
})

const safeData = sanizate(data)
```

有心人可能大概猜到这些api的含义了，我这里简单解释下

* `sa.string`要求这个字段必须为string格式，如果不是string，则会尝试强制转换为string，如果为`null`、`undefined`或者字段不存在则会设置为空字符串。
* `sa.number` 将字段转化为number类型，如果为可以数字组成的字符串，则转化成对应的数字；如果字段为ture/false，则转化为1/0；如果为其他值，则转化为NaN
* `sa.number.required()`在结尾添加`.require()`则意味着这个字段必须为number，如果这个字段不是number类型，则会上报错误
* `sa.filter` 这个api会要求对应字段为一个数组，并且，对数组的每一个进行验证，如果其中某一项上报了错误，则在数组中删除这一项。
* `sa.each` 与`sa.filter`不一样的是，如果数组中的某一项上报错误，则认为整个数组的数据不正确，并将错误继续上报。它要求了凡是数组中存在的数据必须全部正确。
* `sa.len(number)`这个api要求数组长度至少为`number`，如果小于这个数字，则会往数组中填充null。

简单了解这些api之后你会发现，短短十几行代码，比上面几十行代码功能还要强大。同时更容易维护和理解。

### 展示给老板的编辑页面

与展示给客户不同的地方在于，对于错误的价格和数量数据，我们需要让输入框处于未填写状态。

假设我们的价格都是从`<input type="text" />`输入框中输入的。输入框参数和输出往往是字符串。
为了方便操作，我们可以将数据转化成字符串，填充输入框。对于非法数据则填充空字符串，以供老板修正。

```javascript
const sanizate = sa.keys({
	minPrice: sa.number.stringify,
	products: sa.filter({
		items: sa.min(1).each({
			id: sa.number,
			name: sa.string,
			price: sa.number.stringify,
			number: sa.number.stringify,
		},
		price: sa.number.stringify,
	}),
})

const safeData = sanizate(data)
```

* `sa.number.stringify` 将字段转化为number后，再转化为字符串，此时NaN将被转化为空字符串，`.stringify`是`.string`的语法糖


通过`sa.number.stringify`我们可以将非法数字转化为输入框内的合法值或空字符串（而不是渲染成NaN）。
从而提醒老板重新录入数据并保存，解决可能存在的数据库存入脏数据的情况。

## 重复我的论点

我认为，在拿到数据后，我们应当对数据进行**结构校准**、**数据过滤**，将可以直接渲染的数据交给组件模块去渲染，而不是在组件模块中增加一堆复杂的数据逻辑的判断。因为你永远不知道，未来是否有人维护你的代码时，会不会将你的数据传个其他组件去渲染，而并未带走你复杂的排错逻辑。
